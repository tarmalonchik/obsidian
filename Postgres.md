+ [Уровни изоляции транзакций](#уровни%20изоляции%20транзакций)
+ [Индексы](#индексы)
+ [Primary key](#primary%20key)
+ [Составные индексы]
+ [B-tree]
+ [Explain]
+ [Vacuum]
+ [PG bouncer]
+ [Sequence](#sequence)
+ [Serial](#serial)
+ [Партицирование]
+ [Locks]
+ [Transaction versions]
+ [Оптимизация запросов]
+ [Виды JOIN]
+ [Group by]
+ [With and As]
+ Где хранятся структуры b-tree или hash


## Уровни изоляции транзакций

## Индексы

Индексы — это распространенный способ повышения производительности базы данных. Индекс позволяет серверу базы данных находить и извлекать определенные строки гораздо быстрее, чем это было бы возможно без индекса. Но индексы также увеличивают нагрузку на систему баз данных в целом, поэтому их следует использовать разумно.

Postgres поддерживает следующие виды индексов:
+ B-tree - могут обрабатывать запросы на равенство и диапазон данных, которые можно отсортировать в определенном порядке.
	+ В частности, планировщик запросов PostgreSQL будет рассматривать возможность использования индекса B-дерева всякий раз, когда индексированный столбец участвует в сравнении с использованием одного из этих операторов `< <= = >= >`. 
	+ Конструкции, эквивалентные комбинациям этих операторов, такие как BETWEEN и IN, также могут быть реализованы с помощью поиска по индексу B-дерева. 
	+ Кроме того, условие IS NULL или IS NOT NULL для индексного столбца можно использовать с индексом B-дерева.
	+ Оптимизатор также может использовать индекс B-дерева для запросов, включающих операторы сопоставления с образцом `LIKE` и `~,` если шаблон является константой и привязан к началу строки — например, `col LIKE 'foo%'` или `col ~ '^foo'`, но не `col LIKE '%bar'`.
	+ Индексы B-дерева также можно использовать для извлечения данных в отсортированном порядке. Это не всегда быстрее, чем простое сканирование и сортировка, но часто бывает полезно.
+ Hash
	+ Хэш-индексы хранят 32-битный хэш-код, полученный на основе значения индексированного столбца. Следовательно, такие индексы могут обрабатывать только простые сравнения на равенство. Планировщик запросов будет рассматривать возможность использования хеш-индекса всякий раз, когда индексированный столбец участвует в сравнении с использованием оператора равенства:
+ GiST (Generalized Search Tree)
	+ Индексы GiST — это не отдельный вид индексов, а скорее инфраструктура, в рамках которой можно реализовать множество различных стратегий индексирования. Соответственно, конкретные операторы, с которыми можно использовать индекс GiST, различаются в зависимости от стратегии индексирования (класса операторов). Например, стандартная поставка PostgreSQL включает классы операторов GiST для нескольких двумерных геометрических типов данных, которые поддерживают индексированные запросы с использованием этих операторов: `<< &< &> >> <<| &<| |&> |>> @> <@ ~= &&`
	+ сбалансированное по высоте дерево, состоящее из узлов-страниц. Узлы состоят из индексных записей.
+ GIN (Generalized Inverted Index)
	+ Это так называемый _обратный индекс_. Он работает с типами данных, значения которых не являются атомарными, а состоят из элементов. При этом индексируются не сами значения, а отдельные элементы; каждый элемент ссылается на те значения, в которых он встречается.
	+ Основная область применения метода gin — ускорение полнотекстового поиска, поэтому логично рассматривать этот индекс более подробно именно на этом примере.
+ BRIN



## Primary key

## Sequence

Sequence - это не тип. Это объект базы данных, который может создавать последовательности. 

Создание sequence: 
`create sequence 'seq_name';  

Получение значения из sequence:
`select nextval('seq_name'::regclass);`

Объект `sequence` не вызывает проблем при обращении из разных транзакций. При этом разные транзакции получают разные значения. 

## Serial

Serial - это фиктивный тип. Он создает собственный sequence объект, и привязывает его к таблице.  Данный тип был специально создан для работы с `sequence` объектами, который при генерации таблицы превращается примерно в:
```
id integer NOT NULL DEFAULT nextval('tbl_id_seq')`
```

Для того, чтобы не обращаться к sequence по имени, можно использовать функцию для получения имени `sequence`:
```
pg_get_serial_sequence(table_name, column_name)
```

Однако, из за того, что каждая транзакция получает свое уникальное значение, то при откате какой либо транзакции, в последовательности могут быть пробелы. 

`serial` не накладывает каких либо правил по уникальности поля таблицы. Для того, чтобы поле стало уникальным, необходимо создать `unique index`

Начиная **с PostgreSQL 10**, появилась возможность объявления идентифицирующего столбца(`GENERATED AS IDENTITY`), соответствующего стандарту SQL:2003
+ `GENERATED BY DEFAULT AS IDENTITY` - поведение эквивалентно `serial`
+ `GENERATED ALWAYS AS IDENTITY` - отличается от serial тем, что не позволяет вставлять какое либо значение, кроме `defaul`. Для того, чтобы выставить значение отличное от `default`, необходимо воспользоваться командой `OVERRIDING SYSTEM VALUE`. 


